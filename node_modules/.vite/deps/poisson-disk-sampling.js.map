{
  "version": 3,
  "sources": ["../../poisson-disk-sampling/src/tiny-ndarray.js", "../../poisson-disk-sampling/src/sphere-random.js", "../../moore/index.js", "../../poisson-disk-sampling/src/neighbourhood.js", "../../poisson-disk-sampling/src/implementations/fixed-density.js", "../../poisson-disk-sampling/src/implementations/variable-density.js", "../../poisson-disk-sampling/src/poisson-disk-sampling.js"],
  "sourcesContent": ["\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};", "\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n", "module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n", "\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;", "\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n", "\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n", "\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n"],
  "mappings": "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",
  "names": ["dimension"]
}
