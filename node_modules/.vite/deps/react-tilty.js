import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/react-tilty/dist/index.modern.mjs
var import_react = __toESM(require_react(), 1);
function a() {
  return a = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, a.apply(this, arguments);
}
var c = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
var index_modern_default = ({ style: i2 = {}, className: l = "", reverse: s = false, max: u = 35, perspective: d = 1e3, easing: f = "cubic-bezier(0.03,0.98,0.52,0.99)", speed: g = 300, scale: m = 1, axis: p, reset: w = true, glare: h = false, maxGlare: v = 1, glareStyle: y = {}, gyroscope: M = true, gyroscopeMinAngleX: x = -45, gyroscopeMaxAngleX: Y = 45, gyroscopeMinAngleY: E = -45, gyroscopeMaxAngleY: X = 45, onMouseEnter: b = () => {
}, onMouseMove: A = () => {
}, onMouseLeave: $ = () => {
}, onTiltChange: F = () => {
}, children: L }) => {
  const [C, W] = (0, import_react.useState)({ position: "relative", willChange: "transform" }), [N, O] = (0, import_react.useState)({ position: "absolute", top: "50%", left: "50%", pointerEvents: "none", backgroundImage: "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)", transform: "rotate(180deg) translate(-50%, -50%)", transformOrigin: "0% 0%", opacity: "0" }), T = (0, import_react.useRef)(0), q = (0, import_react.useRef)(0), z = (0, import_react.useRef)(0), j = (0, import_react.useRef)(0), I = (0, import_react.useRef)(null), P = (0, import_react.useRef)(null), k = s ? 1 : -1, B = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => () => {
    I.current && clearTimeout(I.current), "undefined" != typeof window && P.current && window.cancelAnimationFrame(P.current);
  }, []), (0, import_react.useEffect)(() => {
    if (!h || "undefined" == typeof window)
      return () => {
      };
    const e2 = () => {
      const { current: e3 } = B;
      null !== e3 && O((t2) => a({}, t2, { width: 2 * e3.offsetWidth, height: 2 * e3.offsetWidth }));
    };
    return window.addEventListener("resize", e2), () => {
      window.removeEventListener("resize", e2);
    };
  }, [h]), c(() => {
    const { current: e2 } = B;
    null !== e2 && O((t2) => a({}, t2, { width: 2 * e2.offsetWidth, height: 2 * e2.offsetWidth }));
  }, []);
  const G = () => {
    const { current: e2 } = B;
    if (null !== e2) {
      const t2 = e2.getBoundingClientRect();
      T.current = e2.offsetWidth, q.current = e2.offsetHeight, z.current = t2.left, j.current = t2.top;
    }
  }, H = (0, import_react.useCallback)((e2) => {
    let t2 = (e2.clientX - z.current) / T.current, n2 = (e2.clientY - j.current) / q.current;
    return t2 = Math.min(Math.max(t2, 0), 1), n2 = Math.min(Math.max(n2, 0), 1), { tiltX: (k * (u / 2 - t2 * u)).toFixed(2), tiltY: (k * (n2 * u - u / 2)).toFixed(2), percentageX: 100 * t2, percentageY: 100 * n2, angle: Math.atan2(e2.clientX - (z.current + T.current / 2), -(e2.clientY - (j.current + q.current / 2))) * (180 / Math.PI) };
  }, [u, k]), R = (0, import_react.useCallback)((e2) => {
    const t2 = H(e2);
    W((e3) => a({}, e3, { transform: `perspective(${d}px) rotateX(${"x" === (null == p ? void 0 : p.toLowerCase()) ? 0 : t2.tiltY}deg) rotateY(${"y" === (null == p ? void 0 : p.toLowerCase()) ? 0 : t2.tiltX}deg) scale3d(${m}, ${m}, ${m})` })), h && O((e3) => a({}, e3, { transform: `rotate(${t2.angle}deg) translate(-50%, -50%)`, opacity: t2.percentageY * v / 100 })), B.current && B.current.dispatchEvent(new CustomEvent("tiltChange", { detail: t2 })), F({ detail: t2 }), P.current = null;
  }, [p, H, h, v, d, m, F]), S = () => {
    I.current && (clearTimeout(I.current), I.current = null), W((e2) => a({}, e2, { transition: `${g}ms ${f}` })), I.current = setTimeout(() => {
      W((e2) => a({}, e2, { transition: "" }));
    }, g);
  };
  return (0, import_react.useEffect)(() => {
    if (!M)
      return () => {
      };
    const e2 = (e3) => {
      if ("undefined" == typeof window || !e3.gamma || !e3.beta)
        return;
      G();
      const t2 = (e3.gamma - x) / ((Y - x) / T.current), n2 = (e3.beta - E) / ((X - E) / q.current);
      null !== P.current && window.cancelAnimationFrame(P.current);
      const r2 = { clientX: t2 + z.current, clientY: n2 + j.current };
      P.current = requestAnimationFrame(() => R(r2));
    };
    return window.addEventListener("deviceorientation", e2), () => {
      window.removeEventListener("deviceorientation", e2);
    };
  }, [M, Y, X, x, E, R]), import_react.default.createElement("div", { ref: B, style: a({}, i2, C), className: l, onMouseEnter: (e2) => (G(), S(), b(e2)), onMouseMove: (e2) => {
    e2.persist(), null !== P.current && "undefined" != typeof window && window.cancelAnimationFrame(P.current);
    const t2 = { clientX: e2.clientX, clientY: e2.clientY };
    return P.current = requestAnimationFrame(() => R(t2)), A(e2);
  }, onMouseLeave: (e2) => (S(), w && "undefined" != typeof window && window.requestAnimationFrame(() => {
    W((e3) => a({}, e3, { transform: `perspective(${d}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)` })), h && O((e3) => a({}, e3, { transform: "rotate(180deg) translate(-50%, -50%)", opacity: 0 }));
  }), $(e2)) }, h && import_react.default.createElement("div", { className: "tilty-glare-wrapper", style: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", overflow: "hidden" } }, import_react.default.createElement("div", { className: "tilty-glare", style: a({}, y, N) })), L);
};
export {
  index_modern_default as default
};
//# sourceMappingURL=react-tilty.js.map
