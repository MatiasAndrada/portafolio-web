{
  "version": 3,
  "sources": ["../../react-tilty/src/index.tsx"],
  "sourcesContent": ["import React, {\n  useState,\n  useRef,\n  useEffect,\n  useLayoutEffect,\n  useCallback,\n} from 'react';\nimport type { CSSProperties, MouseEventHandler, ReactNode } from 'react';\n\nexport interface TiltChangeDetails {\n  /** @example `\"-4.90\"` */\n  tiltX: string;\n  /** @example `\"3.03\"` */\n  tiltY: string;\n  /** @example `64` */\n  percentageX: number;\n  /** @example `58.62` */\n  percentageY: number;\n  /** @example `121.751281` */\n  angle: number;\n}\n\nexport interface TiltChangeEvent {\n  detail: TiltChangeDetails;\n}\n\nexport type TiltChangeEventHandler = (event: TiltChangeEvent) => void;\n\nexport interface Coordinates {\n  clientX: number;\n  clientY: number;\n}\n\nexport interface TiltyProps {\n  /**\n   * A class name to be applied to the component's wrapper div.\n   */\n  className?: string;\n\n  /**\n   * React styles to be applied to the component's wrapper div.\n   */\n  style?: CSSProperties;\n\n  /**\n   * Whether or not to invert the tilt direction.\n   *\n   * @defaultValue `false`\n   */\n  reverse?: boolean;\n\n  /**\n   * The maximum tilt angle in degrees.\n   *\n   * Must be between `0` and `180`.\n   *\n   * @defaultValue `35`\n   */\n  max?: number;\n\n  /**\n   * The perspective of the tilt transform. Lower values mean the tilt effect\n   * is more extreme.\n   *\n   * @defaultValue `1000`\n   */\n  perspective?: number;\n\n  /**\n   * The CSS easing function to use when the mouse enters or leaves the tilt\n   * container.\n   *\n   * @defaultValue `'cubic-bezier(0.03,0.98,0.52,0.99)'`\n   */\n  easing?: string;\n\n  /**\n   * The time in milliseconds the enter/exit transitions will take.\n   *\n   * @defaultValue `300`\n   */\n  speed?: number;\n\n  /**\n   * The amount to scale the tilt container while hovered, relative to its\n   * normal size.\n   *\n   * `1` = 100%, `0.5` = 50%, etc.\n   *\n   * @defaultValue `1`\n   */\n  scale?: number;\n\n  /**\n   * Which axis to disable tilting on, if any.\n   */\n  axis?: 'X' | 'Y';\n\n  /**\n   * Whether or not to reset the tilt effect when the mouse leaves the tilt\n   * container.\n   *\n   * @defaultValue `true`\n   */\n  reset?: boolean;\n\n  /**\n   * Whether or not to add a light glare effect to the tilt container.\n   *\n   * @defaultValue `false`\n   */\n  glare?: boolean;\n\n  /**\n   * The maximum opacity of the glare effect.\n   *\n   * Must be between `0` and `1`.\n   *\n   * @defaultValue `1`\n   */\n  maxGlare?: number;\n\n  /**\n   * React styles to be applied to the glare effect component.\n   */\n  glareStyle?: CSSProperties;\n\n  /**\n   * Whether or not to enable device orientation (gyroscope) support. This only\n   * works on devices that support the DeviceOrientationEvent API (e.g. mobile\n   * devices).\n   *\n   * @defaultValue `true`\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent}\n   */\n  gyroscope?: boolean;\n\n  /**\n   * This is the bottom limit of the device angle on X axis, meaning that a\n   * device rotated at this angle would tilt the element as if the mouse was on\n   * the left border of the element.\n   *\n   * Must be between `-180` and `0`.\n   *\n   * @defaultValue `-45`\n   */\n  gyroscopeMinAngleX?: number;\n\n  /**\n   * This is the top limit of the device angle on X axis, meaning that a device\n   * rotated at this angle would tilt the element as if the mouse was on the\n   * right border of the element.\n   *\n   * Must be between `0` and `180`.\n   *\n   * @defaultValue `45`\n   */\n  gyroscopeMaxAngleX?: number;\n\n  /**\n   * This is the bottom limit of the device angle on Y axis, meaning that a\n   * device rotated at this angle would tilt the element as if the mouse was on\n   * the top border of the element.\n   *\n   * Must be between `-180` and `0`.\n   *\n   * @defaultValue `-45`\n   */\n  gyroscopeMinAngleY?: number;\n\n  /**\n   * his is the top limit of the device angle on Y axis, meaning that a device\n   * rotated at this angle would tilt the element as if the mouse was on the\n   * bottom border of the element.\n   *\n   * Must be between `0` and `180`.\n   *\n   * @defaultValue `45`\n   */\n  gyroscopeMaxAngleY?: number;\n\n  /**\n   * A callback function for the `MouseEnter` synthetic event on the wrapping\n   * div element.\n   *\n   * @see {@link https://reactjs.org/docs/events.html#mouse-events}\n   */\n  onMouseEnter?: MouseEventHandler<HTMLDivElement>;\n\n  /**\n   * A callback function for the `MouseMove` synthetic event on the wrapping\n   * div element.\n   *\n   * @see {@link https://reactjs.org/docs/events.html#mouse-events}\n   */\n  onMouseMove?: MouseEventHandler<HTMLDivElement>;\n\n  /**\n   * A callback function for the `MouseLeave` synthetic event on the wrapping\n   * div element.\n   *\n   * @see {@link https://reactjs.org/docs/events.html#mouse-events}\n   */\n  onMouseLeave?: MouseEventHandler<HTMLDivElement>;\n\n  /**\n   * A callback function for the custom `tiltChange` event on the Tilt\n   * component.\n   *\n   * @param event - A custom event object with a `detail` property containing\n   * tilt angles.\n   */\n  onTiltChange?: TiltChangeEventHandler;\n\n  /**\n   * The children to render inside the `Tilt` component.\n   */\n  children: ReactNode;\n}\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nconst Tilty = ({\n  style = {},\n  className = '',\n  reverse = false,\n  max = 35,\n  perspective = 1000,\n  easing = 'cubic-bezier(0.03,0.98,0.52,0.99)',\n  speed = 300,\n  scale = 1,\n  axis,\n  reset = true,\n  glare = false,\n  maxGlare = 1,\n  glareStyle = {},\n  gyroscope = true,\n  gyroscopeMinAngleX = -45,\n  gyroscopeMaxAngleX = 45,\n  gyroscopeMinAngleY = -45,\n  gyroscopeMaxAngleY = 45,\n  onMouseEnter = () => {},\n  onMouseMove = () => {},\n  onMouseLeave = () => {},\n  onTiltChange = () => {},\n  children,\n}: TiltyProps) => {\n  // VARIABLES\n  const [styleState, setStyle] = useState<CSSProperties>({\n    position: 'relative',\n    willChange: 'transform',\n  });\n  const [glareStyleState, setGlareStyle] = useState<CSSProperties>({\n    position: 'absolute',\n    top: '50%',\n    left: '50%',\n    pointerEvents: 'none',\n    backgroundImage: `linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)`,\n    transform: 'rotate(180deg) translate(-50%, -50%)',\n    transformOrigin: '0% 0%',\n    opacity: '0',\n  });\n\n  const width = useRef<number>(0);\n  const height = useRef<number>(0);\n  const left = useRef<number>(0);\n  const top = useRef<number>(0);\n  const transitionTimeout = useRef<NodeJS.Timeout | null>(null);\n  const updateCall = useRef<number | null>(null);\n\n  const reverseNum = reverse ? 1 : -1;\n\n  const element = useRef<HTMLDivElement>(null);\n\n  // UNMOUNT\n  useEffect(\n    () => () => {\n      if (transitionTimeout.current) {\n        clearTimeout(transitionTimeout.current);\n      }\n      if (typeof window !== 'undefined' && updateCall.current) {\n        window.cancelAnimationFrame(updateCall.current);\n      }\n    },\n    []\n  );\n\n  // GLARE\n  useEffect(() => {\n    if (!glare || typeof window === 'undefined') {\n      return () => {};\n    }\n\n    const updateGlareSize = () => {\n      const { current: currentEl } = element;\n      if (currentEl !== null) {\n        setGlareStyle((prevGlareStyle) => ({\n          ...prevGlareStyle,\n          width: currentEl.offsetWidth * 2,\n          height: currentEl.offsetWidth * 2,\n        }));\n      }\n    };\n\n    window.addEventListener('resize', updateGlareSize);\n\n    return () => {\n      window.removeEventListener('resize', updateGlareSize);\n    };\n  }, [glare]);\n\n  useIsomorphicLayoutEffect(() => {\n    const { current: currentEl } = element;\n    if (currentEl !== null) {\n      setGlareStyle((prevGlareStyle) => ({\n        ...prevGlareStyle,\n        width: currentEl.offsetWidth * 2,\n        height: currentEl.offsetWidth * 2,\n      }));\n    }\n  }, []);\n\n  // TILT FUNCTIONS\n  const updateElementPosition = () => {\n    const { current: currentEl } = element;\n    if (currentEl !== null) {\n      const rect = currentEl.getBoundingClientRect();\n      width.current = currentEl.offsetWidth;\n      height.current = currentEl.offsetHeight;\n      left.current = rect.left;\n      top.current = rect.top;\n    }\n  };\n\n  const getValues = useCallback(\n    (coordinates: Coordinates) => {\n      let x = (coordinates.clientX - left.current) / width.current;\n      let y = (coordinates.clientY - top.current) / height.current;\n\n      x = Math.min(Math.max(x, 0), 1);\n      y = Math.min(Math.max(y, 0), 1);\n\n      const tiltX = (reverseNum * (max / 2 - x * max)).toFixed(2);\n      const tiltY = (reverseNum * (y * max - max / 2)).toFixed(2);\n\n      const angle =\n        Math.atan2(\n          coordinates.clientX - (left.current + width.current / 2),\n          -(coordinates.clientY - (top.current + height.current / 2))\n        ) *\n        (180 / Math.PI);\n\n      const percentageX = x * 100;\n      const percentageY = y * 100;\n\n      return {\n        tiltX,\n        tiltY,\n        percentageX,\n        percentageY,\n        angle,\n      };\n    },\n    [max, reverseNum]\n  );\n\n  const update = useCallback(\n    (coordinates: Coordinates) => {\n      const values = getValues(coordinates);\n\n      setStyle((prevStyle) => ({\n        ...prevStyle,\n        transform: `perspective(${perspective}px) rotateX(${\n          axis?.toLowerCase() === 'x' ? 0 : values.tiltY\n        }deg) rotateY(${\n          axis?.toLowerCase() === 'y' ? 0 : values.tiltX\n        }deg) scale3d(${scale}, ${scale}, ${scale})`,\n      }));\n\n      if (glare) {\n        setGlareStyle((prevGlareStyle) => ({\n          ...prevGlareStyle,\n          transform: `rotate(${values.angle}deg) translate(-50%, -50%)`,\n          opacity: (values.percentageY * maxGlare) / 100,\n        }));\n      }\n\n      // fire tiltChange event and callback\n      if (element.current) {\n        element.current.dispatchEvent(\n          new CustomEvent('tiltChange', {\n            detail: values,\n          })\n        );\n      }\n\n      onTiltChange({ detail: values });\n\n      updateCall.current = null;\n    },\n    [axis, getValues, glare, maxGlare, perspective, scale, onTiltChange]\n  );\n\n  const setTransition = () => {\n    if (transitionTimeout.current) {\n      clearTimeout(transitionTimeout.current);\n      transitionTimeout.current = null;\n    }\n\n    setStyle((prevStyle) => ({\n      ...prevStyle,\n      transition: `${speed}ms ${easing}`,\n    }));\n\n    transitionTimeout.current = setTimeout(() => {\n      setStyle((prevStyle) => ({\n        ...prevStyle,\n        transition: '',\n      }));\n    }, speed);\n  };\n\n  const handleReset = () => {\n    if (typeof window !== 'undefined') {\n      window.requestAnimationFrame(() => {\n        setStyle((prevStyle) => ({\n          ...prevStyle,\n          transform: `perspective(${perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`,\n        }));\n\n        if (glare) {\n          setGlareStyle((prevGlareStyle) => ({\n            ...prevGlareStyle,\n            transform: 'rotate(180deg) translate(-50%, -50%)',\n            opacity: 0,\n          }));\n        }\n      });\n    }\n  };\n\n  // MOUSE EVENTS\n  const handleMouseEnter: MouseEventHandler<HTMLDivElement> = (e) => {\n    updateElementPosition();\n    setTransition();\n    return onMouseEnter(e);\n  };\n\n  const handleMouseMove: MouseEventHandler<HTMLDivElement> = (e) => {\n    e.persist();\n    if (updateCall.current !== null && typeof window !== 'undefined') {\n      window.cancelAnimationFrame(updateCall.current);\n    }\n    const coordinates = {\n      clientX: e.clientX,\n      clientY: e.clientY,\n    };\n    updateCall.current = requestAnimationFrame(() => update(coordinates));\n    return onMouseMove(e);\n  };\n\n  const handleMouseLeave: MouseEventHandler<HTMLDivElement> = (e) => {\n    setTransition();\n\n    if (reset) {\n      handleReset();\n    }\n\n    return onMouseLeave(e);\n  };\n\n  // DEVICE GYROSCOPE TILTING\n  useEffect(() => {\n    if (!gyroscope) {\n      return () => {};\n    }\n\n    const onDeviceOrientation = (e: DeviceOrientationEvent) => {\n      if (typeof window === 'undefined' || !e.gamma || !e.beta) {\n        return;\n      }\n\n      updateElementPosition();\n\n      const totalAngleX = gyroscopeMaxAngleX - gyroscopeMinAngleX;\n      const totalAngleY = gyroscopeMaxAngleY - gyroscopeMinAngleY;\n\n      const degreesPerPixelX = totalAngleX / width.current;\n      const degreesPerPixelY = totalAngleY / height.current;\n\n      const angleX = e.gamma - gyroscopeMinAngleX;\n      const angleY = e.beta - gyroscopeMinAngleY;\n\n      const posX = angleX / degreesPerPixelX;\n      const posY = angleY / degreesPerPixelY;\n\n      if (updateCall.current !== null) {\n        window.cancelAnimationFrame(updateCall.current);\n      }\n\n      const coordinates = {\n        clientX: posX + left.current,\n        clientY: posY + top.current,\n      };\n\n      updateCall.current = requestAnimationFrame(() => update(coordinates));\n    };\n\n    window.addEventListener('deviceorientation', onDeviceOrientation);\n\n    return () => {\n      window.removeEventListener('deviceorientation', onDeviceOrientation);\n    };\n  }, [\n    gyroscope,\n    gyroscopeMaxAngleX,\n    gyroscopeMaxAngleY,\n    gyroscopeMinAngleX,\n    gyroscopeMinAngleY,\n    update,\n  ]);\n\n  return (\n    <div\n      ref={element}\n      style={{\n        ...style,\n        ...styleState,\n      }}\n      className={className}\n      onMouseEnter={handleMouseEnter}\n      onMouseMove={handleMouseMove}\n      onMouseLeave={handleMouseLeave}\n    >\n      {glare && (\n        <div\n          className=\"tilty-glare-wrapper\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            overflow: 'hidden',\n          }}\n        >\n          <div\n            className=\"tilty-glare\"\n            style={{\n              ...glareStyle,\n              ...glareStyleState,\n            }}\n          />\n        </div>\n      )}\n      {children}\n    </div>\n  );\n};\n\nexport default Tilty;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AA6NA,IAAMA,IACc,eAAA,OAAXC,SAAyBC,aAAAA,kBAAkBC,aAAAA;AAAAA,IAAAA,uBAEtC,CAAA,EACZC,OAAAA,KAAQ,CAAA,GACRC,WAAAA,IAAY,IACZC,SAAAA,IAAAA,OACAC,KAAAA,IAAM,IACNC,aAAAA,IAAc,KACdC,QAAAA,IAAS,qCACTC,OAAAA,IAAQ,KACRC,OAAAA,IAAQ,GACRC,MAAAA,GACAC,OAAAA,IAAAA,MACAC,OAAAA,IAAAA,OACAC,UAAAA,IAAW,GACXC,YAAAA,IAAa,CAAA,GACbC,WAAAA,IAAAA,MACAC,oBAAAA,IAAAA,KACAC,oBAAAA,IAAqB,IACrBC,oBAAAA,IAAAA,KACAC,oBAAAA,IAAqB,IACrBC,cAAAA,IAAe,MAAA;AAAA,GACfC,aAAAA,IAAc,MAAA;AAAA,GACdC,cAAAA,IAAe,MAAA;AAAA,GACfC,cAAAA,IAAe,MAAA;AAAA,GACfC,UAAAA,EAAAA,MAAAA;AAGA,QAAA,CAAOC,GAAYC,CAAAA,QAAYC,aAAAA,UAAwB,EACrDC,UAAU,YACVC,YAAY,YAAA,CAAA,GAAA,CAEPC,GAAiBC,CAAAA,QAAiBJ,aAAAA,UAAwB,EAC/DC,UAAU,YACVI,KAAK,OACLC,MAAM,OACNC,eAAe,QACfC,iBAAAA,2EACAC,WAAW,wCACXC,iBAAiB,SACjBC,SAAS,IAAA,CAAA,GAGLC,QAAQC,aAAAA,QAAe,CAAA,GACvBC,QAASD,aAAAA,QAAe,CAAA,GACxBP,QAAOO,aAAAA,QAAe,CAAA,GACtBR,QAAMQ,aAAAA,QAAe,CAAA,GACrBE,QAAoBF,aAAAA,QAA8B,IAAA,GAClDG,QAAaH,aAAAA,QAAsB,IAAA,GAEnCI,IAAaxC,IAAU,IAAA,IAEvByC,QAAUL,aAAAA,QAAuB,IAAA;AAGvCvC,mBAAAA,WACE,MAAM,MAAA;AACAyC,MAAkBI,WACpBC,aAAaL,EAAkBI,OAAAA,GAEX,eAAA,OAAX/C,UAA0B4C,EAAWG,WAC9C/C,OAAOiD,qBAAqBL,EAAWG,OAAAA;EACxC,GAEH,CAAA,CAAA,OAIF7C,aAAAA,WAAU,MAAA;AACR,QAAA,CAAKW,KAA2B,eAAA,OAAXb;AACnB,aAAO,MAAA;MAAA;AAGT,UAAMkD,KAAkB,MAAA;AACtB,YAAA,EAAQH,SAASI,GAAAA,IAAcL;AACb,eAAdK,MACFnB,EAAeoB,CAAAA,OAAAA,EAAAA,CAAAA,GACVA,IAAAA,EACHZ,OAA+B,IAAxBW,GAAUE,aACjBX,QAAgC,IAAxBS,GAAUE,YAAAA,CAAAA,CAAAA;IAErB;AAKH,WAFArD,OAAOsD,iBAAiB,UAAUJ,EAAAA,GAE3B,MAAA;AACLlD,aAAOuD,oBAAoB,UAAUL,EAAAA;IAAAA;EACtC,GACA,CAACrC,CAAAA,CAAAA,GAEJd,EAA0B,MAAA;AACxB,UAAA,EAAQgD,SAASI,GAAAA,IAAcL;AACb,aAAdK,MACFnB,EAAeoB,CAAAA,OAAAA,EAAAA,CAAAA,GACVA,IAAAA,EACHZ,OAA+B,IAAxBW,GAAUE,aACjBX,QAAgC,IAAxBS,GAAUE,YAAAA,CAAAA,CAAAA;EAErB,GACA,CAAA,CAAA;AAGH,QAAMG,IAAwB,MAAA;AAC5B,UAAA,EAAQT,SAASI,GAAAA,IAAcL;AAC/B,QAAkB,SAAdK,IAAoB;AACtB,YAAMM,KAAON,GAAUO,sBAAAA;AACvBlB,QAAMO,UAAUI,GAAUE,aAC1BX,EAAOK,UAAUI,GAAUQ,cAC3BzB,EAAKa,UAAUU,GAAKvB,MACpBD,EAAIc,UAAUU,GAAKxB;IACpB;EAAA,GAGG2B,QAAYC,aAAAA,aACfC,CAAAA,OAAAA;AACC,QAAIC,MAAKD,GAAYE,UAAU9B,EAAKa,WAAWP,EAAMO,SACjDkB,MAAKH,GAAYI,UAAUjC,EAAIc,WAAWL,EAAOK;AAkBrD,WAhBAgB,KAAII,KAAKC,IAAID,KAAK7D,IAAIyD,IAAG,CAAA,GAAI,CAAA,GAC7BE,KAAIE,KAAKC,IAAID,KAAK7D,IAAI2D,IAAG,CAAA,GAAI,CAAA,GAetB,EACLI,QAdaxB,KAAcvC,IAAM,IAAIyD,KAAIzD,IAAMgE,QAAQ,CAAA,GAevDC,QAda1B,KAAcoB,KAAI3D,IAAMA,IAAM,IAAIgE,QAAQ,CAAA,GAevDE,aANsB,MAAJT,IAOlBU,aANsB,MAAJR,IAOlBS,OAdAP,KAAKQ,MACHb,GAAYE,WAAW9B,EAAKa,UAAUP,EAAMO,UAAU,IAAA,EACpDe,GAAYI,WAAWjC,EAAIc,UAAUL,EAAOK,UAAU,GAAA,KAEzD,MAAMoB,KAAKS,IAAAA;EAKP,GAQT,CAACtE,GAAKuC,CAAAA,CAAAA,GAGFgC,QAAShB,aAAAA,aACZC,CAAAA,OAAAA;AACC,UAAMgB,KAASlB,EAAUE,EAAAA;AAEzBnC,MAAUoD,CAAAA,OAAAA,EAAAA,CAAAA,GACLA,IAAAA,EACH1C,WAAAA,eAA0B9B,gBACA,SAAA,QAAxBI,IAAAA,SAAAA,EAAMqE,YAAAA,KAAwB,IAAIF,GAAOP,qBAEjB,SAAA,QAAxB5D,IAAAA,SAAAA,EAAMqE,YAAAA,KAAwB,IAAIF,GAAOT,qBAC3B3D,MAAUA,MAAUA,KAAAA,CAAAA,CAAAA,GAGlCG,KACFmB,EAAeoB,CAAAA,OAAAA,EAAAA,CAAAA,GACVA,IAAAA,EACHf,WAAAA,UAAqByC,GAAOJ,mCAC5BnC,SAAUuC,GAAOL,cAAc3D,IAAY,IAAA,CAAA,CAAA,GAK3CgC,EAAQC,WACVD,EAAQC,QAAQkC,cACd,IAAIC,YAAY,cAAc,EAC5BC,QAAQL,GAAAA,CAAAA,CAAAA,GAKdtD,EAAa,EAAE2D,QAAQL,GAAAA,CAAAA,GAEvBlC,EAAWG,UAAU;EAAA,GAEvB,CAACpC,GAAMiD,GAAW/C,GAAOC,GAAUP,GAAaG,GAAOc,CAAAA,CAAAA,GAGnD4D,IAAgB,MAAA;AAChBzC,MAAkBI,YACpBC,aAAaL,EAAkBI,OAAAA,GAC/BJ,EAAkBI,UAAU,OAG9BpB,EAAUoD,CAAAA,OAAAA,EAAAA,CAAAA,GACLA,IAAAA,EACHM,YAAAA,GAAe5E,OAAWD,IAAAA,CAAAA,CAAAA,GAG5BmC,EAAkBI,UAAUuC,WAAW,MAAA;AACrC3D,QAAUoD,CAAAA,OAAAA,EAAAA,CAAAA,GACLA,IAAAA,EACHM,YAAY,GAAA,CAAA,CAAA;IAAA,GAEb5E,CAAAA;EAAAA;AAuGL,aAlDAP,aAAAA,WAAU,MAAA;AACR,QAAA,CAAKc;AACH,aAAO,MAAA;MAAA;AAGT,UAAMuE,KAAuBC,CAAAA,OAAAA;AAC3B,UAAsB,eAAA,OAAXxF,UAAAA,CAA2BwF,GAAEC,SAAAA,CAAUD,GAAEE;AAClD;AAGFlC,QAAAA;AAEA,YASMmC,MAHSH,GAAEC,QAAQxE,OANLC,IAAqBD,KAGFuB,EAAMO,UAOvC6C,MAHSJ,GAAEE,OAAOvE,OANJC,IAAqBD,KAGFuB,EAAOK;AAQnB,eAAvBH,EAAWG,WACb/C,OAAOiD,qBAAqBL,EAAWG,OAAAA;AAGzC,YAAMe,KAAc,EAClBE,SAAS2B,KAAOzD,EAAKa,SACrBmB,SAAS0B,KAAO3D,EAAIc,QAAAA;AAGtBH,QAAWG,UAAU8C,sBAAsB,MAAMhB,EAAOf,EAAAA,CAAAA;IAAAA;AAK1D,WAFA9D,OAAOsD,iBAAiB,qBAAqBiC,EAAAA,GAEtC,MAAA;AACLvF,aAAOuD,oBAAoB,qBAAqBgC,EAAAA;IAAAA;EACjD,GACA,CACDvE,GACAE,GACAE,GACAH,GACAE,GACA0D,CAAAA,CAAAA,GAIAiB,aAAAA,QAAAA,cAAAA,OAAAA,EACEC,KAAKjD,GACL3C,OAAAA,EAAAA,CAAAA,GACKA,IACAuB,CAAAA,GAELtB,WAAWA,GACXiB,cAxFyDmE,CAAAA,QAC3DhC,EAAAA,GACA4B,EAAAA,GACO/D,EAAamE,EAAAA,IAsFlBlE,aAnFwDkE,CAAAA,OAAAA;AAC1DA,IAAAA,GAAEQ,QAAAA,GACyB,SAAvBpD,EAAWG,WAAsC,eAAA,OAAX/C,UACxCA,OAAOiD,qBAAqBL,EAAWG,OAAAA;AAEzC,UAAMe,KAAc,EAClBE,SAASwB,GAAExB,SACXE,SAASsB,GAAEtB,QAAAA;AAGb,WADAtB,EAAWG,UAAU8C,sBAAsB,MAAMhB,EAAOf,EAAAA,CAAAA,GACjDxC,EAAYkE,EAAAA;EAAD,GA0EhBjE,cAvEyDiE,CAAAA,QAC3DJ,EAAAA,GAEIxE,KAzCkB,eAAA,OAAXZ,UACTA,OAAO6F,sBAAsB,MAAA;AAC3BlE,MAAUoD,CAAAA,OAAAA,EAAAA,CAAAA,GACLA,IAAAA,EACH1C,WAAAA,eAA0B9B,oDAAAA,CAAAA,CAAAA,GAGxBM,KACFmB,EAAeoB,CAAAA,OAAAA,EAAAA,CAAAA,GACVA,IAAAA,EACHf,WAAW,wCACXE,SAAS,EAAA,CAAA,CAAA;EAEZ,CAAA,GAgCEhB,EAAaiE,EAAAA,GAAAA,GAkEjB3E,KACCiF,aAAAA,QAAAA,cAAAA,OAAAA,EACE1F,WAAU,uBACVD,OAAO,EACL0B,UAAU,YACVI,KAAK,GACLC,MAAM,GACNM,OAAO,QACPE,QAAQ,QACRuD,UAAU,SAAA,EAAA,GAGZH,aAAAA,QAAAA,cAAAA,OAAAA,EACE1F,WAAU,eACVD,OAAAA,EAAAA,CAAAA,GACKY,GACAgB,CAAAA,EAAAA,CAAAA,CAAAA,GAKVN,CAAAA;AAhCH;",
  "names": ["useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "style", "className", "reverse", "max", "perspective", "easing", "speed", "scale", "axis", "reset", "glare", "maxGlare", "glareStyle", "gyroscope", "gyroscopeMinAngleX", "gyroscopeMaxAngleX", "gyroscopeMinAngleY", "gyroscopeMaxAngleY", "onMouseEnter", "onMouseMove", "onMouseLeave", "onTiltChange", "children", "styleState", "setStyle", "useState", "position", "willChange", "glareStyleState", "setGlareStyle", "top", "left", "pointerEvents", "backgroundImage", "transform", "transformOrigin", "opacity", "width", "useRef", "height", "transitionTimeout", "updateCall", "reverseNum", "element", "current", "clearTimeout", "cancelAnimationFrame", "updateGlareSize", "currentEl", "prevGlareStyle", "offsetWidth", "addEventListener", "removeEventListener", "updateElementPosition", "rect", "getBoundingClientRect", "offsetHeight", "getValues", "useCallback", "coordinates", "x", "clientX", "y", "clientY", "Math", "min", "tiltX", "toFixed", "tiltY", "percentageX", "percentageY", "angle", "atan2", "PI", "update", "values", "prevStyle", "toLowerCase", "dispatchEvent", "CustomEvent", "detail", "setTransition", "transition", "setTimeout", "onDeviceOrientation", "e", "gamma", "beta", "posX", "posY", "requestAnimationFrame", "React", "ref", "persist", "overflow"]
}
