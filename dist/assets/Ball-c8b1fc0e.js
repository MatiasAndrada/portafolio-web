import{l as C,r as s,ao as be,au as ke,av as Me,aw as ve,J as De,a1 as Ee,$ as we,ax as Fe,ay as K,N as $e,k as ye,az as ne,an as ie,q as le,U as Ie,aA as Pe,aB as Q,O as Be,aC as He,a0 as Le,R as P,ar as Ge}from"./index-26168e69.js";import{O as Ne}from"./OrbitControls-6f17d610.js";const Z=new C,ce=new C,Ue=new C;function Ze(e,r,o){const a=Z.setFromMatrixPosition(e.matrixWorld);a.project(r);const c=o.width/2,u=o.height/2;return[a.x*c+c,-(a.y*u)+u]}function _e(e,r){const o=Z.setFromMatrixPosition(e.matrixWorld),a=ce.setFromMatrixPosition(r.matrixWorld),c=o.sub(a),u=r.getWorldDirection(Ue);return c.angleTo(u)>Math.PI/2}function Xe(e,r,o,a){const c=Z.setFromMatrixPosition(e.matrixWorld),u=c.clone();u.project(r),o.setFromCamera(u,r);const b=o.intersectObjects(a,!0);if(b.length){const W=b[0].distance;return c.distanceTo(o.ray.origin)<W}return!0}function qe(e,r){if(r instanceof Ee)return r.zoom;if(r instanceof we){const o=Z.setFromMatrixPosition(e.matrixWorld),a=ce.setFromMatrixPosition(r.matrixWorld),c=r.fov*Math.PI/180,u=o.distanceTo(a);return 1/(2*Math.tan(c/2)*u)}else return 1}function Je(e,r,o){if(r instanceof we||r instanceof Ee){const a=Z.setFromMatrixPosition(e.matrixWorld),c=ce.setFromMatrixPosition(r.matrixWorld),u=a.distanceTo(c),b=(o[1]-o[0])/(r.far-r.near),W=o[1]-b*r.far;return Math.round(b*u+W)}}const ae=e=>Math.abs(e)<1e-10?0:e;function Ae(e,r,o=""){let a="matrix3d(";for(let c=0;c!==16;c++)a+=ae(r[c]*e.elements[c])+(c!==15?",":")");return o+a}const Ke=(e=>r=>Ae(r,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Qe=(e=>(r,o)=>Ae(r,e(o),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Ye(e){return e&&typeof e=="object"&&"current"in e}const Ve=s.forwardRef(({children:e,eps:r=.001,style:o,className:a,prepend:c,center:u,fullscreen:b,portal:W,distanceFactor:g,sprite:j=!1,transform:M=!1,occlude:h,onOcclude:z,castShadow:x,receiveShadow:v,material:t,geometry:n,zIndexRange:i=[16777271,0],calculatePosition:d=Ze,as:l="div",wrapperClass:S,pointerEvents:w="auto",...m},L)=>{const{gl:y,camera:f,scene:A,size:E,raycaster:Y,events:V,viewport:ee}=be(),[O]=s.useState(()=>document.createElement(l)),te=s.useRef(),T=s.useRef(null),fe=s.useRef(0),_=s.useRef([0,0]),G=s.useRef(null),re=s.useRef(null),B=(W==null?void 0:W.current)||V.connected||y.domElement.parentNode,D=s.useRef(null),X=s.useRef(!1),q=s.useMemo(()=>h&&h!=="blending"||Array.isArray(h)&&h.length&&Ye(h[0]),[h]);s.useLayoutEffect(()=>{const R=y.domElement;h&&h==="blending"?(R.style.zIndex=`${Math.floor(i[0]/2)}`,R.style.position="absolute",R.style.pointerEvents="none"):(R.style.zIndex=null,R.style.position=null,R.style.pointerEvents=null)},[h]),s.useLayoutEffect(()=>{if(T.current){const R=te.current=ke(O);if(A.updateMatrixWorld(),M)O.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const p=d(T.current,f,E);O.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${p[0]}px,${p[1]}px,0);transform-origin:0 0;`}return B&&(c?B.prepend(O):B.appendChild(O)),()=>{B&&B.removeChild(O),R.unmount()}}},[B,M]),s.useLayoutEffect(()=>{S&&(O.className=S)},[S]);const me=s.useMemo(()=>M?{position:"absolute",top:0,left:0,width:E.width,height:E.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:u?"translate3d(-50%,-50%,0)":"none",...b&&{top:-E.height/2,left:-E.width/2,width:E.width,height:E.height},...o},[o,u,b,E,M]),Se=s.useMemo(()=>({position:"absolute",pointerEvents:w}),[w]);s.useLayoutEffect(()=>{if(X.current=!1,M){var R;(R=te.current)==null||R.render(s.createElement("div",{ref:G,style:me},s.createElement("div",{ref:re,style:Se},s.createElement("div",{ref:L,className:a,style:o,children:e}))))}else{var p;(p=te.current)==null||p.render(s.createElement("div",{ref:L,style:me,className:a,children:e}))}});const H=s.useRef(!0);Me(R=>{if(T.current){f.updateMatrixWorld(),T.current.updateWorldMatrix(!0,!1);const p=M?_.current:d(T.current,f,E);if(M||Math.abs(fe.current-f.zoom)>r||Math.abs(_.current[0]-p[0])>r||Math.abs(_.current[1]-p[1])>r){const F=_e(T.current,f);let k=!1;q&&(h!=="blending"?k=[A]:Array.isArray(h)&&(k=h.map($=>$.current)));const N=H.current;if(k){const $=Xe(T.current,f,Y,k);H.current=$&&!F}else H.current=!F;N!==H.current&&(z?z(!H.current):O.style.display=H.current?"block":"none");const J=Math.floor(i[0]/2),Oe=h?q?[i[0],J]:[J-1,0]:i;if(O.style.zIndex=`${Je(T.current,f,Oe)}`,M){const[$,de]=[E.width/2,E.height/2],oe=f.projectionMatrix.elements[5]*de,{isOrthographicCamera:pe,top:We,left:je,bottom:Re,right:ze}=f,Te=Ke(f.matrixWorldInverse),Ce=pe?`scale(${oe})translate(${ae(-(ze+je)/2)}px,${ae((We+Re)/2)}px)`:`translateZ(${oe}px)`;let I=T.current.matrixWorld;j&&(I=f.matrixWorldInverse.clone().transpose().copyPosition(I).scale(T.current.scale),I.elements[3]=I.elements[7]=I.elements[11]=0,I.elements[15]=1),O.style.width=E.width+"px",O.style.height=E.height+"px",O.style.perspective=pe?"":`${oe}px`,G.current&&re.current&&(G.current.style.transform=`${Ce}${Te}translate(${$}px,${de}px)`,re.current.style.transform=Qe(I,1/((g||10)/400)))}else{const $=g===void 0?1:qe(T.current,f)*g;O.style.transform=`translate3d(${p[0]}px,${p[1]}px,0) scale(${$})`}_.current=p,fe.current=f.zoom}}if(!q&&D.current&&!X.current)if(M){if(G.current){const p=G.current.children[0];if(p!=null&&p.clientWidth&&p!=null&&p.clientHeight){const{isOrthographicCamera:F}=f;if(F||n)m.scale&&(Array.isArray(m.scale)?m.scale instanceof C?D.current.scale.copy(m.scale.clone().divideScalar(1)):D.current.scale.set(1/m.scale[0],1/m.scale[1],1/m.scale[2]):D.current.scale.setScalar(1/m.scale));else{const k=(g||10)/400,N=p.clientWidth*k,J=p.clientHeight*k;D.current.scale.set(N,J,1)}X.current=!0}}}else{const p=O.children[0];if(p!=null&&p.clientWidth&&p!=null&&p.clientHeight){const F=1/ee.factor,k=p.clientWidth*F,N=p.clientHeight*F;D.current.scale.set(k,N,1),X.current=!0}D.current.lookAt(R.camera.position)}});const he=s.useMemo(()=>({vertexShader:M?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[M]);return s.createElement("group",ve({},m,{ref:T}),h&&!q&&s.createElement("mesh",{castShadow:x,receiveShadow:v,ref:D},n||s.createElement("planeGeometry",null),t||s.createElement("shaderMaterial",{side:De,vertexShader:he.vertexShader,fragmentShader:he.fragmentShader})))});let U=0;const et=Fe(e=>(K.onStart=(r,o,a)=>{e({active:!0,item:r,loaded:o,total:a,progress:(o-U)/(a-U)*100})},K.onLoad=()=>{e({active:!1})},K.onError=r=>e(o=>({errors:[...o.errors,r]})),K.onProgress=(r,o,a)=>{o===a&&(U=a),e({active:!0,item:r,loaded:o,total:a,progress:(o-U)/(a-U)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));class tt extends $e{constructor(r,o,a,c){super();const u=[],b=[],W=[],g=new C,j=new ye;j.makeRotationFromEuler(a),j.setPosition(o);const M=new ye;M.copy(j).invert(),h(),this.setAttribute("position",new ne(u,3)),this.setAttribute("normal",new ne(b,3)),this.setAttribute("uv",new ne(W,2));function h(){let t,n=[];const i=new C,d=new C;if(r.geometry.isGeometry===!0){console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");return}const l=r.geometry,S=l.attributes.position,w=l.attributes.normal;if(l.index!==null){const m=l.index;for(t=0;t<m.count;t++)i.fromBufferAttribute(S,m.getX(t)),d.fromBufferAttribute(w,m.getX(t)),z(n,i,d)}else for(t=0;t<S.count;t++)i.fromBufferAttribute(S,t),d.fromBufferAttribute(w,t),z(n,i,d);for(n=x(n,g.set(1,0,0)),n=x(n,g.set(-1,0,0)),n=x(n,g.set(0,1,0)),n=x(n,g.set(0,-1,0)),n=x(n,g.set(0,0,1)),n=x(n,g.set(0,0,-1)),t=0;t<n.length;t++){const m=n[t];W.push(.5+m.position.x/c.x,.5+m.position.y/c.y),m.position.applyMatrix4(j),u.push(m.position.x,m.position.y,m.position.z),b.push(m.normal.x,m.normal.y,m.normal.z)}}function z(t,n,i){n.applyMatrix4(r.matrixWorld),n.applyMatrix4(M),i.transformDirection(r.matrixWorld),t.push(new xe(n.clone(),i.clone()))}function x(t,n){const i=[],d=.5*Math.abs(c.dot(n));for(let l=0;l<t.length;l+=3){let S,w,m,L=0,y,f,A,E;const Y=t[l+0].position.dot(n)-d,V=t[l+1].position.dot(n)-d,ee=t[l+2].position.dot(n)-d;switch(S=Y>0,w=V>0,m=ee>0,L=(S?1:0)+(w?1:0)+(m?1:0),L){case 0:{i.push(t[l]),i.push(t[l+1]),i.push(t[l+2]);break}case 1:{if(S&&(y=t[l+1],f=t[l+2],A=v(t[l],y,n,d),E=v(t[l],f,n,d)),w){y=t[l],f=t[l+2],A=v(t[l+1],y,n,d),E=v(t[l+1],f,n,d),i.push(A),i.push(f.clone()),i.push(y.clone()),i.push(f.clone()),i.push(A.clone()),i.push(E);break}m&&(y=t[l],f=t[l+1],A=v(t[l+2],y,n,d),E=v(t[l+2],f,n,d)),i.push(y.clone()),i.push(f.clone()),i.push(A),i.push(E),i.push(A.clone()),i.push(f.clone());break}case 2:{S||(y=t[l].clone(),f=v(y,t[l+1],n,d),A=v(y,t[l+2],n,d),i.push(y),i.push(f),i.push(A)),w||(y=t[l+1].clone(),f=v(y,t[l+2],n,d),A=v(y,t[l],n,d),i.push(y),i.push(f),i.push(A)),m||(y=t[l+2].clone(),f=v(y,t[l],n,d),A=v(y,t[l+1],n,d),i.push(y),i.push(f),i.push(A));break}}}return i}function v(t,n,i,d){const l=t.position.dot(i)-d,S=n.position.dot(i)-d,w=l/(l-S);return new xe(new C(t.position.x+w*(n.position.x-t.position.x),t.position.y+w*(n.position.y-t.position.y),t.position.z+w*(n.position.z-t.position.z)),new C(t.normal.x+w*(n.normal.x-t.normal.x),t.normal.y+w*(n.normal.y-t.normal.y),t.normal.z+w*(n.normal.z-t.normal.z)))}}}class xe{constructor(r,o){this.position=r,this.normal=o}clone(){return new this.constructor(this.position.clone(),this.normal.clone())}}const ge=e=>e===Object(e)&&!Array.isArray(e)&&typeof e!="function";function ue(e,r){const o=be(c=>c.gl),a=ie(le,ge(e)?Object.values(e):e);if(s.useLayoutEffect(()=>{r==null||r(a)},[r]),s.useEffect(()=>{(Array.isArray(a)?a:[a]).forEach(o.initTexture)},[o,a]),ge(e)){const c=Object.keys(e),u={};return c.forEach(b=>Object.assign(u,{[b]:a[c.indexOf(b)]})),u}else return a}ue.preload=e=>ie.preload(le,e);ue.clear=e=>ie.clear(le,e);function rt(e){return Array.isArray(e)}function se(e=[0,0,0]){return rt(e)?e:e instanceof C||e instanceof Pe?[e.x,e.y,e.z]:[e,e,e]}const ot=s.forwardRef(function({debug:r,mesh:o,children:a,position:c,rotation:u,scale:b,...W},g){const j=s.useRef(null);s.useImperativeHandle(g,()=>j.current);const M=s.useRef(null);return s.useLayoutEffect(()=>{const h=(o==null?void 0:o.current)||j.current.parent,z=j.current;if(!(h instanceof Ie))throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');const x={position:new C,rotation:new Pe,scale:new C(1,1,1)};if(h){Q(x,{position:c,scale:b});const v=h.matrixWorld.clone();if(h.matrixWorld.identity(),!u||typeof u=="number"){const t=new Be;t.position.copy(x.position),t.lookAt(h.position),typeof u=="number"&&t.rotateZ(u),Q(x,{rotation:t.rotation})}else Q(x,{rotation:u});return z.geometry=new tt(h,x.position,x.rotation,x.scale),M.current&&Q(M.current,x),h.matrixWorld=v,()=>{z.geometry.dispose()}}},[o,...se(c),...se(b),...se(u)]),s.createElement("mesh",{ref:j},a||s.createElement("meshStandardMaterial",ve({transparent:!0,polygonOffset:!0,polygonOffsetFactor:-10},W)),r&&s.createElement("mesh",{ref:M},s.createElement("boxGeometry",null),s.createElement("meshNormalMaterial",{wireframe:!0}),s.createElement("axesHelper",null)))}),nt=s.forwardRef(({children:e,enabled:r=!0,speed:o=1,rotationIntensity:a=1,floatIntensity:c=1,floatingRange:u=[-.1,.1],...b},W)=>{const g=s.useRef(null),j=s.useRef(Math.random()*1e4);return Me(M=>{var h,z;if(!r||o===0)return;const x=j.current+M.clock.getElapsedTime();g.current.rotation.x=Math.cos(x/4*o)/8*a,g.current.rotation.y=Math.sin(x/4*o)/8*a,g.current.rotation.z=Math.sin(x/4*o)/20*a;let v=Math.sin(x/4*o)/10;v=Le.mapLinear(v,-.1,.1,(h=u==null?void 0:u[0])!==null&&h!==void 0?h:-.1,(z=u==null?void 0:u[1])!==null&&z!==void 0?z:.1),g.current.position.y=v*c,g.current.updateMatrix()}),s.createElement("group",b,s.createElement("group",{ref:He([g,W]),matrixAutoUpdate:!1},e))}),st=()=>{const{progress:e}=et();return P.createElement(Ve,null,P.createElement("span",{className:"canvas-load"},P.createElement("p",{style:{fontSize:16,color:"#f1f1f1",fontWeight:800,marginTop:0}},e,"%")))},at=e=>{const[r]=ue([e.imgUrl]);return P.createElement(nt,{speed:1.75,rotationIntensity:.2,floatIntensity:.2},P.createElement("ambientLight",{intensity:.25}),P.createElement("directionalLight",{position:[0,0,.05]}),P.createElement("mesh",{castShadow:!0,receiveShadow:!0,scale:2.75},P.createElement("icosahedronGeometry",{args:[1,1]}),P.createElement("meshStandardMaterial",{color:"#fff8eb",polygonOffset:!0,polygonOffsetFactor:-5,flatShading:!0}),P.createElement(ot,{position:[0,0,1],rotation:[2*Math.PI,0,6.25],scale:1,map:r,flatShading:!0,opacity:.9})))},ct=({technologies:e})=>(console.log(e),P.createElement(Ge,{frameloop:"demand",dpr:[1,2],gl:{preserveDrawingBuffer:!0}},P.createElement(s.Suspense,{fallback:P.createElement(st,null)},e.map((r,o)=>P.createElement("div",{className:"w-28 h-28",key:o},P.createElement(Ne,{enableZoom:!1,enablePan:!0,minAzimuthAngle:-Math.PI/4,maxAzimuthAngle:Math.PI/4,minPolarAngle:Math.PI/2-Math.PI/18,maxPolarAngle:Math.PI/2+Math.PI/18,enableDamping:!0,dampingFactor:.05,target:[0,0,0]}),P.createElement(at,{key:o,imgUrl:r.icon}),P.createElement("span",{className:"text-white text-[12px] font-semibold capitalize select-none"},r.name))))));export{ct as default};
